package com.hytaledocs.intellij.run

import com.intellij.execution.RunManager
import com.intellij.openapi.diagnostic.Logger
import com.intellij.openapi.project.Project
import com.intellij.openapi.startup.ProjectActivity
import java.io.File

/**
 * Startup activity that creates a default Hytale Server run configuration
 * if one doesn't exist and the project appears to be a Hytale plugin project.
 */
class HytaleRunConfigurationSetup : ProjectActivity {

    companion object {
        private val LOG = Logger.getInstance(HytaleRunConfigurationSetup::class.java)
    }

    override suspend fun execute(project: Project) {
        // Check if this looks like a Hytale plugin project
        if (!isHytaleProject(project)) {
            LOG.info("Not a Hytale project, skipping run configuration setup")
            return
        }

        // Check if we already have a Hytale Server run configuration
        val runManager = RunManager.getInstance(project)
        val existingSettings = runManager.allSettings
            .find { it.type is HytaleServerConfigurationType }

        if (existingSettings != null) {
            val existingConfig = existingSettings.configuration as? HytaleServerRunConfiguration
            // If config exists but is incomplete (missing plugin name), try to reconfigure
            if (existingConfig != null && existingConfig.pluginName.isBlank()) {
                LOG.info("Existing config has empty plugin name, attempting to reconfigure")
                val pluginInfo = detectPluginInfo(project)
                if (pluginInfo != null) {
                    existingConfig.pluginJarPath = pluginInfo.jarPath
                    existingConfig.pluginName = "${pluginInfo.groupId}:${pluginInfo.artifactId}"
                    existingConfig.buildTask = pluginInfo.buildTask
                    // Force save the configuration
                    runManager.makeStable(existingSettings)
                    LOG.info("Reconfigured existing run config: ${pluginInfo.groupId}:${pluginInfo.artifactId}")
                } else {
                    LOG.warn("Could not detect plugin info to reconfigure")
                }
            } else {
                LOG.info("Hytale Server run configuration already exists and is configured")
            }
            return
        }

        // Try to detect plugin info from various sources
        val pluginInfo = detectPluginInfo(project)
        if (pluginInfo == null) {
            LOG.warn("Could not detect plugin info, creating config with defaults")
            createDefaultRunConfiguration(project)
            return
        }

        LOG.info("Detected plugin info: ${pluginInfo.groupId}:${pluginInfo.artifactId}")

        // Create the run configuration
        createHytaleServerRunConfiguration(project, pluginInfo)
    }

    private fun isHytaleProject(project: Project): Boolean {
        val basePath = project.basePath ?: return false

        // Check for Hytale-specific indicators
        val indicators = listOf(
            File(basePath, ".hytale/project.json"),
            File(basePath, "server/HytaleServer.jar"),
            File(basePath, "libs/HytaleServer.jar"),
            File(basePath, "src/main/resources/manifest.json")
        )

        val hasIndicator = indicators.any { it.exists() }

        // Also check for Hytale dependency in build.gradle
        val buildGradle = File(basePath, "build.gradle")
        val buildGradleKts = File(basePath, "build.gradle.kts")
        val hasHytaleDep = when {
            buildGradle.exists() -> buildGradle.readText().contains("HytaleServer")
            buildGradleKts.exists() -> buildGradleKts.readText().contains("HytaleServer")
            else -> false
        }

        return hasIndicator || hasHytaleDep
    }

    private data class PluginInfo(
        val groupId: String,
        val artifactId: String,
        val jarPath: String,
        val buildTask: String
    )

    private fun detectPluginInfo(project: Project): PluginInfo? {
        val basePath = project.basePath ?: return null

        // Priority 0: Try to read .hytale/project.json (generated by wizard)
        val hytaleProjectInfo = readHytaleProjectJson(basePath)
        if (hytaleProjectInfo != null) {
            LOG.info("Plugin info from .hytale/project.json")
            return hytaleProjectInfo
        }

        // Priority 1: Try to read manifest.json
        val manifestInfo = readManifestJson(basePath)
        if (manifestInfo != null) {
            LOG.info("Plugin info from manifest.json")
            return manifestInfo
        }

        // Priority 2: Try to read from settings.gradle + build.gradle
        val gradleInfo = readGradleFiles(basePath)
        if (gradleInfo != null) {
            LOG.info("Plugin info from Gradle files")
            return gradleInfo
        }

        // Priority 3: Use project name as fallback
        val projectName = project.name
        if (projectName.isNotBlank()) {
            LOG.info("Plugin info from project name: $projectName")
            val artifactId = projectName.lowercase().replace(" ", "-")
            return PluginInfo(
                groupId = "com.example",
                artifactId = artifactId,
                jarPath = "build/libs/$artifactId-1.0.0.jar",
                buildTask = "shadowJar"
            )
        }

        return null
    }

    private fun readHytaleProjectJson(basePath: String): PluginInfo? {
        val projectFile = File(basePath, ".hytale/project.json")
        if (!projectFile.exists()) return null

        return try {
            val content = projectFile.readText()

            val groupRegex = """"groupId"\s*:\s*"([^"]+)"""".toRegex()
            val artifactRegex = """"artifactId"\s*:\s*"([^"]+)"""".toRegex()
            val modNameRegex = """"modName"\s*:\s*"([^"]+)"""".toRegex()
            val jarPathRegex = """"jarPath"\s*:\s*"([^"]+)"""".toRegex()
            val buildTaskRegex = """"buildTask"\s*:\s*"([^"]+)"""".toRegex()

            val groupId = groupRegex.find(content)?.groupValues?.get(1) ?: return null
            val artifactId = artifactRegex.find(content)?.groupValues?.get(1) ?: return null
            // modName is the actual plugin name (with spaces/caps), artifactId is for JAR filename
            val modName = modNameRegex.find(content)?.groupValues?.get(1) ?: artifactId
            val jarPath = jarPathRegex.find(content)?.groupValues?.get(1) ?: "build/libs/$artifactId-1.0.0.jar"
            val buildTask = buildTaskRegex.find(content)?.groupValues?.get(1) ?: "shadowJar"

            PluginInfo(
                groupId = groupId,
                artifactId = modName,  // Use modName for plugin commands (Group:Name format)
                jarPath = jarPath,
                buildTask = buildTask
            )
        } catch (e: Exception) {
            LOG.warn("Failed to parse .hytale/project.json", e)
            null
        }
    }

    private fun readManifestJson(basePath: String): PluginInfo? {
        val manifestFile = File(basePath, "src/main/resources/manifest.json")
        if (!manifestFile.exists()) return null

        return try {
            val content = manifestFile.readText()
            // Simple JSON parsing for Group and Name
            val groupRegex = """"Group"\s*:\s*"([^"]+)"""".toRegex()
            val nameRegex = """"Name"\s*:\s*"([^"]+)"""".toRegex()

            val group = groupRegex.find(content)?.groupValues?.get(1)
            val name = nameRegex.find(content)?.groupValues?.get(1)

            if (group != null && name != null) {
                val isGradle = File(basePath, "build.gradle").exists() ||
                        File(basePath, "build.gradle.kts").exists()

                // artifactId for JAR filename (lowercase, no spaces)
                val jarArtifactId = name.lowercase().replace(" ", "-")

                PluginInfo(
                    groupId = group,
                    artifactId = name,  // Keep original name for plugin commands
                    jarPath = if (isGradle) "build/libs/$jarArtifactId-1.0.0.jar" else "target/$jarArtifactId-1.0.0.jar",
                    buildTask = if (isGradle) "shadowJar" else "package"
                )
            } else null
        } catch (e: Exception) {
            LOG.warn("Failed to parse manifest.json", e)
            null
        }
    }

    private fun readGradleFiles(basePath: String): PluginInfo? {
        // Try settings.gradle first for project name
        val settingsGradle = File(basePath, "settings.gradle")
        val settingsGradleKts = File(basePath, "settings.gradle.kts")

        val projectName = when {
            settingsGradle.exists() -> {
                val content = settingsGradle.readText()
                // rootProject.name = 'my-plugin'
                val regex = """rootProject\.name\s*=\s*['"]([^'"]+)['"]""".toRegex()
                regex.find(content)?.groupValues?.get(1)
            }
            settingsGradleKts.exists() -> {
                val content = settingsGradleKts.readText()
                val regex = """rootProject\.name\s*=\s*"([^"]+)"""".toRegex()
                regex.find(content)?.groupValues?.get(1)
            }
            else -> null
        }

        // Try build.gradle for group
        val buildGradle = File(basePath, "build.gradle")
        val buildGradleKts = File(basePath, "build.gradle.kts")

        val groupId = when {
            buildGradle.exists() -> {
                val content = buildGradle.readText()
                // group = 'com.example.myplugin'
                val regex = """group\s*=\s*['"]([^'"]+)['"]""".toRegex()
                regex.find(content)?.groupValues?.get(1)
            }
            buildGradleKts.exists() -> {
                val content = buildGradleKts.readText()
                val regex = """group\s*=\s*"([^"]+)"""".toRegex()
                regex.find(content)?.groupValues?.get(1)
            }
            else -> null
        }

        if (projectName != null) {
            val artifactId = projectName.lowercase().replace(" ", "-")
            // Extract base group (remove last segment which is often the module name)
            val baseGroup = groupId?.substringBeforeLast('.') ?: "com.example"

            return PluginInfo(
                groupId = baseGroup,
                artifactId = artifactId,
                jarPath = "build/libs/$artifactId-1.0.0.jar",
                buildTask = "shadowJar"
            )
        }

        return null
    }

    private fun createDefaultRunConfiguration(project: Project) {
        val runManager = RunManager.getInstance(project)
        val configType = HytaleServerConfigurationType.getInstance()
        val factory = configType.configurationFactories.first()

        val settings = runManager.createConfiguration("Hytale Server", factory)
        val config = settings.configuration as HytaleServerRunConfiguration

        // Set defaults without plugin info
        config.buildBeforeRun = true
        config.buildTask = "shadowJar"
        config.deployPlugin = true
        config.pluginJarPath = "" // User needs to configure
        config.pluginName = "" // User needs to configure
        config.serverPath = "server"
        config.minMemory = "2G"
        config.maxMemory = "8G"
        config.port = 5520
        config.authMode = "authenticated"
        config.allowOp = true
        config.acceptEarlyPlugins = true
        config.hotReloadEnabled = true

        // Make configuration permanent (not temporary) and editable
        settings.isTemporary = false
        runManager.addConfiguration(settings)
        runManager.makeStable(settings)
        runManager.selectedConfiguration = settings

        LOG.info("Created default Hytale Server run configuration (needs manual plugin config)")
    }

    private fun createHytaleServerRunConfiguration(project: Project, pluginInfo: PluginInfo) {
        val runManager = RunManager.getInstance(project)
        val configType = HytaleServerConfigurationType.getInstance()
        val factory = configType.configurationFactories.first()

        val settings = runManager.createConfiguration("Hytale Server", factory)
        val config = settings.configuration as HytaleServerRunConfiguration

        // Configure with detected values
        config.buildBeforeRun = true
        config.buildTask = pluginInfo.buildTask
        config.deployPlugin = true
        config.pluginJarPath = pluginInfo.jarPath
        config.pluginName = "${pluginInfo.groupId}:${pluginInfo.artifactId}"
        config.serverPath = "server"
        config.minMemory = "2G"
        config.maxMemory = "8G"
        config.port = 5520
        config.authMode = "authenticated"
        config.allowOp = true
        config.acceptEarlyPlugins = true
        config.hotReloadEnabled = true

        // Make configuration permanent (not temporary) and editable
        settings.isTemporary = false
        runManager.addConfiguration(settings)
        runManager.makeStable(settings)
        runManager.selectedConfiguration = settings

        LOG.info("Created Hytale Server run configuration: ${pluginInfo.groupId}:${pluginInfo.artifactId}")
    }
}
